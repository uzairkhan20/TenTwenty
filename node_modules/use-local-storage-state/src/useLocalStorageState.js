"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const storage_1 = __importDefault(require("./storage"));
const react_dom_1 = require("react-dom");
const react_1 = require("react");
// `activeHooks` holds all active hooks. we use the array to update all hooks with the same key —
// calling `setValue` of one hook triggers an update for all other hooks with the same key
const activeHooks = new Set();
function useLocalStorageState(key, options) {
    const defaultValue = options === null || options === void 0 ? void 0 : options.defaultValue;
    // SSR support
    if (typeof window === 'undefined') {
        return [defaultValue, () => { }, { isPersistent: true, removeItem: () => { } }];
    }
    // eslint-disable-next-line react-hooks/rules-of-hooks
    return useClientLocalStorageState(key, defaultValue, (options === null || options === void 0 ? void 0 : options.ssr) === true);
}
exports.default = useLocalStorageState;
function useClientLocalStorageState(key, defaultValue, ssr) {
    const initialDefaultValue = (0, react_1.useRef)(defaultValue).current;
    // `id` changes every time a change in the `localStorage` occurs
    const [id, forceUpdate] = (0, react_1.useReducer)((number) => number + 1, 0);
    const updateHooks = (0, react_1.useCallback)(() => {
        (0, react_dom_1.unstable_batchedUpdates)(() => {
            // - it fixes "🐛 `setValue()` during render doesn't work":
            //   https://github.com/astoilkov/use-local-storage-state/issues/43
            forceUpdate();
            for (const hook of activeHooks) {
                if (hook.key === key) {
                    hook.forceUpdate();
                }
            }
        });
    }, [key]);
    const setState = (0, react_1.useCallback)((newValue) => {
        storage_1.default.set(key, newValue instanceof Function
            ? newValue(storage_1.default.get(key, initialDefaultValue))
            : newValue);
        updateHooks();
    }, [key, updateHooks, initialDefaultValue]);
    // - syncs change across tabs, windows, iframe's
    // - the `storage` event is called only in all tabs, windows, iframe's except the one that
    //   triggered the change
    (0, react_1.useEffect)(() => {
        const onStorage = (e) => {
            if (e.storageArea === localStorage && e.key === key) {
                forceUpdate();
            }
        };
        window.addEventListener('storage', onStorage);
        return () => window.removeEventListener('storage', onStorage);
    }, [key]);
    // - adds this hook to the `activeHooks` array. see the `activeHooks` declaration above for a
    //   more detailed explanation
    (0, react_1.useLayoutEffect)(() => {
        const hook = { key, forceUpdate };
        activeHooks.add(hook);
        return () => {
            activeHooks.delete(hook);
        };
    }, [key]);
    // - SSR support
    // - not inside a `useLayoutEffect` because this way we skip the calls to `useEffect()` and
    //   `useLayoutEffect()` for the first render (which also increases performance)
    // - inspired by: https://github.com/astoilkov/use-local-storage-state/pull/40
    // - related: https://github.com/astoilkov/use-local-storage-state/issues/39
    // - related: https://github.com/astoilkov/use-local-storage-state/issues/43
    const isFirstRenderRef = (0, react_1.useRef)(true);
    const isPossiblyHydrating = ssr && isFirstRenderRef.current;
    isFirstRenderRef.current = false;
    if (isPossiblyHydrating &&
        (storage_1.default.data.has(key) || initialDefaultValue !== storage_1.default.get(key, initialDefaultValue))) {
        forceUpdate();
    }
    // initial issue: https://github.com/astoilkov/use-local-storage-state/issues/26
    // issues that were caused by incorrect initial and secondary implementations:
    // - https://github.com/astoilkov/use-local-storage-state/issues/30
    // - https://github.com/astoilkov/use-local-storage-state/issues/33
    if (initialDefaultValue !== undefined &&
        !storage_1.default.data.has(key) &&
        localStorage.getItem(key) === null) {
        storage_1.default.set(key, initialDefaultValue);
    }
    return (0, react_1.useMemo)(() => [
        isPossiblyHydrating ? initialDefaultValue : storage_1.default.get(key, initialDefaultValue),
        setState,
        {
            isPersistent: isPossiblyHydrating || !storage_1.default.data.has(key),
            removeItem() {
                storage_1.default.remove(key);
                updateHooks();
            },
        },
    ], 
    // disabling eslint warning for the following reasons:
    // - `id` is needed because when it changes that means the data in `localStorage` has
    //   changed and we need to update the returned value. However, the eslint rule wants us to
    //   remove the `id` from the dependencies array.
    // - `defaultValue` never changes so we can skip it and reduce package size
    // - `setState` changes when `key` changes so we can skip it and reduce package size
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [id, key]);
}
